import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
action code {:          :};

parser code {:
		SMPLLexer lexer;

		public SMPLParser(SMPLLexer l) {
                    super(l);
                    lexer = l;
                }

		public SMPLParser(String file) throws FileNotFoundException {
	            this(new HPLLexer(new FileReader(file)));
		}

                public SMPLParser(InputStream is) {
                    this(new SMPLLexer(is));
                }

		public void report_error(String message, Object info) {
		    System.err.println(message + info);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error while reading: ", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
		// No longer necessary		
	  :};
scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println ("Unrecognised token at line: " + 
                                lexer.getLine() + ", char: " + lexer.getChar());
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

/* Keywords */
terminal ASSIGN;
terminal LET, WAIT;

/* Arithmetic operators */ 
terminal PLUS, MINUS, TIMES, DIV, MOD;
/* Punctuation */
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LCBRACKET, RCBRACKET, SEMI, COMMA, COLON, IN, DEF, PROC, PRINT, PRINTLN, PAIR, CAR, CDR, LIST, SUBSTR, EQV, EQUAL, POW, IF, THEN, ELSE, CMP, NOT, AND, OR;

terminal Integer INTEGER;
terminal Integer HEXINT;
terminal Integer BININT;
terminal Double FRACTION;
terminal Double REAL;
terminal String VAR;
terminal String STRING;

/* Non terminals */
non terminal SMPLProgram program;

non terminal SMPLSequence stmtList;
non terminal SMPLStatement stmt;
non terminal SMPLIfStmt ifstatement;
non terminal SMPLAssignment assignment;
non terminal SMPLStatement waitStmt;
non terminal SMPLPrintStmt printStatement;

non terminal ASTExp tlExp;
non terminal ASTBinaryExp<AIRExp> expression;
non terminal ASTCmpBinaryExp<AIRExp> cmpExp;
non terminal ASTLogBinaryExp<AIRExp> orStmt;
non terminal ASTLogBinaryExp<AIRExp> andStmt;
non terminal ASTLogBinaryExp<AIRExp> notStmt;
non terminal ASTPairExp pairExp;
non terminal ASTCarExp carExp;
non terminal ASTCdrExp cdrExp;
non terminal ASTListExp listExp;
non terminal ASTEqvExp eqvExp;
non terminal ASTEqualExp equalExp;
non terminal ASTSubstrExp substrExp;
non terminal ASTExp<AIRExp> term;
non terminal ASTExp<AIRExp> power;
non terminal ASTExp<AIRExp> factor;

non terminal ArrayList<ASTExp> expList;   /* non-empty exp list */
non terminal ArrayList<ASTExp> expListE;   /* potentially empty exp list */

non terminal SMPLFunDef funDef;
non terminal SMPLFunCall funCall;

non terminal ArrayList<String> paramList;
non terminal ArrayList<String> paramListE;
non terminal empty;

/* Grammar rules */

start with program;

program ::= stmtList:seq {:
		RESULT = new SMPLProgram(seq);
	    :};

stmtList ::= stmtList:seq stmt:s {: 
				seq.addStatement(s);
		    	RESULT = seq; :} |
	         empty {: RESULT = new SMPLSequence(); :};

stmt ::=   assignment:a {: RESULT = a; :} |
		   printStatement:p {: RESULT = p; :} |
		   //ifstatement:i {: RESULT = i; :} |
		   funDef:f {: RESULT = f; :};


//ifstatement ::= IF tlExp:c THEN stmtList:s {: new SMPLIfStmt(c, s); :} |
				//IF tlExp:c THEN stmtList:s ELSE stmtList:l {: RESULT = new  SMPLIfStmt(c, s, l); :};


assignment ::= VAR:v ASSIGN tlExp:c SEMI {:RESULT = new ExpAssign(v, c); :};

printStatement ::= PRINT tlExp:e SEMI{: RESULT = new SMPLPrintStmt("", e); :} |
				   PRINTLN tlExp:e SEMI{: RESULT = new SMPLPrintStmt("\n", e); :};

tlExp ::= pairExp:p {: RESULT = p; :} |
		  carExp:car {: RESULT = car; :} |
		  cdrExp:cdr {: RESULT = cdr; :} |
		  listExp:list {: RSULT = list; :} |
		  eqvExp:eqv {: RESULT = eqv; :} |
		  equalExp:equal {: RESULT = equal; :} |
		  substrExp:sub {: RESULT = sub; :} |
		  orStmt:o {: RESULT = o; :} |
		  STRING:str {: RESULT = str; :} |
   		  funCall:s {: RESULT = s; :};


pairExp ::= PAIR LPAREN tlExp:e1 COMMA tlExp:e2 RPAREN {: RESULT = new ASTPairExp(e1, e2); :};

carExp ::= CAR tlExp:e {: RESULT = new ASTCarExp(e); :};

cdrExp ::= CDR tlExp:e {: RESULT = new ASTCdrExp(e); :};

listExp ::= LIST LPAREN expList:e RPAREN {: RESULT = new ASTListExp(e); :} |
			LBRACKET expList:e RBRACKET{: RESULT = new ASTListExp(e); :};

eqvExp ::= EQV LPAREN tlExp:e1 COMMA tlExp:e2 RPAREN {: RESULT = new ASTEqvExp(e1, e2); :};

equalExp ::= EQUAL LPAREN tlExp:e1 COMMA tlExp:e2 RPAREN {: RESULT = new ASTEqualExp(e1, e2); :};

substrExp ::= EQUAL LPAREN tlExp:t COMMA INTEGER:int COMMA INTEGER:int2 RPAREN {: RESULT = new ASTSubstrExp(t, int, int2); :};


orStmt ::= orStmt:o OR andStmt:a {: RESULT = new ASTLogBinaryExp<AIRExp>(o, "or", a); :} |
		   andStmt:a {: RESULT = a; :};
 
andStmt ::= andStmt:a AND notStmt:n {: RESULT = new ASTLogBinaryExp<AIRExp>(a, "and", n); :} |
			notStmt:n {: RESULT = n; :};

notStmt ::= NOT cmpExp:c {: RESULT = new ASTUnaryExp<AIRExp>("not", e); :} |
			cmpExp:c {: RESULT = c; :};



cmpExp ::= cmpExp:c CMP:m expression:e {: RESULT = new ASTCmpBinaryExp<AIRExp>(c, m, e); :} | 
			   LPAREN cmpExp:c RPAREN {: RESULT = c; :} |
			   expression:e {: RESULT = e; :};


expression ::=  expression:e PLUS term:t {: RESULT = new ASTBinaryExp<AIRExp>("+", e, t); :} |
				expression:e MINUS term:t {: RESULT = new ASTBinaryExp<AIRExp>("-", e, t); :} |
				term:t {: RESULT = t :};



term ::= term:t TIMES power:f {: RESULT = new ASTBinaryExp<AIRExp>("*", e, t); :} |
		 term:t DIV power:f {: RESULT = new ASTBinaryExp<AIRExp>("/", e, t); :} |
		 term:t MOD power:f {: RESULT = new ASTBinaryExp<AIRExp>("%", e, t); :} |
		 power:p {: RESULT = p; :}; //Editted:- 14/12/2015_6:30pm



power ::= power:p POW factor:f {: RESULT = new ASTBinaryExp<AIRExp>("^", e, t); :} |
		  factor:f {:RESULT = f; :}; //Editted:- 14/12/2015_6:30pm


factor ::= INTEGER:int {: RESULT = int; :} |
		   FRACTION:frac {: RESULT = frac; :} |
		   REAL:rl {:RESULT = rl; :} |
		   HEXINT:h {: RESULT = h; :} |
		   BININT:b {: RESULT = b; :} |
		   LPAREN MINUS factor:f RPAREN {: RESULT = new ASTBinaryExp<AIRExp>("-", new AIRExpInt(0), f) :} ; //Editted:- 14/12/2015_7:20pm



funCall ::= VAR:name LPAREN expListE:p RPAREN {:
		RESULT = new SMPLFunCall(name, p); :} ; //



funDef ::= DEF VAR:name PROC LPAREN paramListE:p RPAREN LCBRACKET stmtList:s RCBRACKET {:
			RESULT = new SMPLFunDef(name, p, s); |
			DEF VAR:name PROC LPAREN paramListE:p RPAREN stmtList:s {:
			RESULT = new SMPLFunDef(name, p, s); :}; 


paramListE ::= paramList:lst {: RESULT = lst; :} |
	       empty {: RESULT = new ArrayList<>(); :} ;

paramList ::= paramList:lst COMMA VAR:id {:
		lst.add(id);
		RESULT = lst; :} |
	      VAR:id {:
		RESULT = new ArrayList<>();
		RESULT.add(id);
	      :};

expList ::= expList:lst COMMA cmpExp:e {:
	          lst.add(e);
		  RESULT = lst;
	     :} |
	     cmpExp:e {:
		  RESULT = new ArrayList<>();
		  RESULT.add(e);
	     :}; 

expListE ::= expList:lst {: RESULT = lst; :} |
	      empty {: RESULT = new ArrayList<>(); :}; 

empty ::= ;
