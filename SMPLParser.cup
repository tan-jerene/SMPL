//package hpl.lang;


import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
action code {:          :};

parser code {:
		HPLLexer lexer;

		public HPLParser(HPLLexer l) {
                    super(l);
                    lexer = l;
                }

		public HPLParser(String file) throws FileNotFoundException {
	            this(new HPLLexer(new FileReader(file)));
		}

                public HPLParser(InputStream is) {
                    this(new HPLLexer(is));
                }

		public void report_error(String message, Object info) {
		    System.err.println(message + info);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error while reading: ", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
	    :};

init with {:
		// No longer necessary		
	  :};
scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println ("Unrecognised token at line: " + 
                                lexer.getLine() + ", char: " + lexer.getChar());
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
	  :};

/* Terminals (tokens returned by the scanner). */

/* Keywords */
terminal ASSIGN;
terminal LET, WAIT;

/* Arithmetic operators */ 
terminal PLUS, MINUS, TIMES, DIV, MOD;
/* Punctuation */
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, SEMI, COMMA, COLON, IN, DEF, PROC, PRINT, PRINTLN, PAIR, CAR, CDR, LIST, SUBSTR, IF, THEN;

terminal Integer INTEGER;
terminal Double FRACTION;
terminal Double REAL;
terminal String VAR;
terminal String STRING;

/* Non terminals */
non terminal SMPLProgram program;

non terminal SMPLSequence stmtList;
non terminal SMPLStatement stmt;
non terminal SMPLStatement waitStmt;
non terminal SMPLPaintStmt printStmt;

non terminal ASTExp expression;
non terminal ASTExp cmpExp;
non terminal ASTPairExp pairExp;
non terminal ASTCarExp carExp;
non terminal ASTCdrExp cdrExp;
non terminal ASTListExp listExp;
non terminal ASTEqvExp eqvExp;
non terminal ASTEqualExp equalExp;
non terminal ASTSubstrExp substrExp;
non terminal ASTExp<AIRExp> term;
non terminal ASTExp<AIRExp> power;
non terminal ASTExp<AIRExp> factor;

non terminal ArrayList<ASTExp> expList;   /* non-empty exp list */
non terminal ArrayList<ASTExp> expListE;   /* potentially empty exp list */

non terminal SMPLFunDef funDef;
non terminal SMPLFunCall funCall;
non terminal SMPLFrameExp subFrameExp;

non terminal ArrayList<String> paramList;
non terminal ArrayList<String> paramListE;
non terminal empty;

/* Grammar rules */

start with program;

program ::= stmtList:seq {:
		RESULT = new SMPLProgram(seq);
	    :};

stmtList ::= stmtList:seq stmt:s {: 
				seq.addStatement(s);
		    	RESULT = seq; :} |
	         empty {: RESULT = new SMPLSequence(); :};

stmt ::=   assignment:a {: RESULT = a; :} |
		   waitStmt:w {: RESULT = w; :} |
		   expression:e {: RESULT = e; :} |
		   printStmt:p {: RESULT = p; :} |
		   ifstatement:i {: RESULT = i; :};

waitStmt ::= WAIT arithExp:t {: RESULT = new SMPLWaitStmt(t); :};

assignment ::= VAR:v ASSIGN comparison:c {:RESULT = new ExpAssign(v, c); :};

printStatement ::= PRINT expression:e {: RESULT = new SMPLPrintStmt("", e); :} |
				   PRINTLN expression:e {: RESULT = new SMPLPrintStmt("\n", e); :};

/**********************CONDITIONAL FUNCTIONALITY*********************/
/* 
   	** CONDITIONAL STATEMENTS 
       NON-TERMINALS USED:         
	       ASTExp comparison            
	       SMPLSequence stmtList       
       Last editted:- 15/12/2015_2:00pm
   	**
*/
ifstatement ::= IF cmpExp:c THEN stmtList:s { new SMPLIfStmt(c, s); } |
				IF cmpExp:c THEN stmtList:s ELSE stmtList:l {: RESULT = new  SMPLIfStmt(c, s, l)};

/* 
   	** COMPARISON
       NON-TERMINALS USED:              
	       ASTExp cmpExp
	       ASTExp expression  
       Last editted:- 15/12/2015_2:00pm
   	**
*/
cmpExp ::= cmpExp:c CMP:m expression:e {: RESULT = new ASTBinaryExp<AIRExp>(c, m, e); } |
			   LPAREN cmpExp:c RPAREN {: RESULT = c; :} |
			   expression:e {: RESULT = e; :};
/********************************************************************/

/* 
   	** EXPRESSION 
       NON-TERMINALS USED:              
	       ASTExp expression
	       ASTExp<AIRExp> term 
	       SMPLFunCall funCall 
       Last editted:- 15/12/2015_3:00pm
   	**
*/
expression ::=  expression:e PLUS term:t {: RESULT = new ASTBinaryExp<AIRExp>("+", e, t); :} |
				expression:e MINUS term:t {: RESULT = new ASTBinaryExp<AIRExp>("-", e, t); :} |
				pairExp:p {: RESULT = p; :} |
				carExp:car {: RESULT = car; :} |
				cdrExp:cdr {: RESULT = cdr; :} |
				listExp:list {: RSULT = list; :} |
				eqvExp:eqv {: RESULT = eqv; :} |
				equalExp:equal {: RESULT = equal; :} |
				substrExp:sub {: RESULT = sub; :} |
	        	LPAREN expression:e RPAREN {: RESULT = e; :} |
	   			funCall:s {: RESULT = s; :} |
				term:t {: RESULT = t :};

pairExp ::= PAIR LPAREN expression:e1 COMMA expression:e2 RPAREN {: RESULT = new ASTPairExp(e1, e2); :};

carExp ::= CAR expression:e {: RESULT = new ASTCarExp(e); :};

cdrExp ::= CDR expression:e {: RESULT = new ASTCdrExp(e); :};

listExp ::= LIST LPAREN LBRACKET expList:e RBRACKET RPAREN {: RESULT = new ASTListExp(e); :};

eqvExp ::= EQV LPAREN expression:e1 COMMA expression:e2 RPAREN {: RESULT = new ASTEqvExp(e1, e2); :};

equalExp ::= EQUAL LPAREN expression:e1 COMMA expression:e2 RPAREN {: RESULT = new ASTEqualExp(e1, e2); :};

substrExp ::= EQUAL LPAREN STRING:str COMMA INTEGER:int COMMA INTEGER:int2 RPAREN {: RESULT = new ASTSubstrExp(str, int, int2); :};



/* 
   	** TERM
       NON-TERMINALS USED:              
	       ASTExp<AIRExp> term 
	       ASTExp<AIRExp> power 
       Last editted:- 15/12/2015_3:00pm
   	**
*/
term ::= term:t TIMES power:f {: RESULT = new ASTBinaryExp<AIRExp>("*", e, t); :} |
		 term:t DIV power:f {: RESULT = new ASTBinaryExp<AIRExp>("/", e, t); :} |
		 term:t MOD power:f {: RESULT = new ASTBinaryExp<AIRExp>("%", e, t); :} |
		 power:p {: RESULT = p; :}; //Editted:- 14/12/2015_6:30pm

/* 
   	** POWER
       NON-TERMINALS USED:      
	       ASTExp<AIRExp> power        
	       ASTExp<AIRExp> factor 
       Last editted:- 15/12/2015_3:00pm
   	**
*/
power ::= power:p POW factor:f {: RESULT = new ASTBinaryExp<AIRExp>("^", e, t); :} |
		  factor:f {:RESULT = f; :}; //Editted:- 14/12/2015_6:30pm

/* 
   	** FACTOR 
       NON-TERMINALS USED:              
	       ASTExp<AIRExp> factor 
       TERMINALS USED:        
       	   Integer INTEGER
       	   Double FRACTION
       	   Double Real
       Last editted:- 15/12/2015_3:00pm
   	**
*/
factor ::= INTEGER:int {: RESULT = int; :} |
		   FRACTION:frac {: RESULT = frac; :} |
		   REAL:rl {:RESULT = rl; :} |
		   STRING:str {: RESULT = str; :} |
		   LPAREN MINUS factor:f RPAREN {: RESULT = new ASTBinaryOperator("-", new AIRExpInt(0), f) :} ; //Editted:- 14/12/2015_7:20pm

/*
	** FUNCTION CALL SECTION
	   NON-TERMINAL USED:
	   		ArrayList<ASTExp> expListE
       TERMINALS USED:
	   		String VAR
	**
*/
funCall ::= VAR:name LPAREN expListE:p RPAREN {:
		RESULT = new SMPLFunCall(name, p); :} ; //

/* 
   	** FUNCTION DEFINITION SECTION 
       NON-TERMINALS USED:              
	       ArrayList<String> paramListE
	       SMPLSequence stmtList   
       TERMINALS USED:        
       	   String VAR     
       Last editted:- 14/12/2015_5:00pm
   	**
*/

funDef ::= DEF VAR:name PROC LPAREN paramListE:p RPAREN LCBRACKET stmtList:s RCBRACKET {:
			RESULT = new SMPLFunDef(name, p, s);
		  :} ; 


paramListE ::= paramList:lst {: RESULT = lst; :} |
	       empty {: RESULT = new ArrayList<>(); :} ;

paramList ::= paramList:lst COMMA VAR:id {:
		lst.add(id);
		RESULT = lst; :} |
	      VAR:id {:
		RESULT = new ArrayList<>();
		RESULT.add(id);
	      :};

expList ::= expList:lst COMMA exp:e {:
	          lst.add(e);
		  RESULT = lst;
	     :} |
	     exp:e {:
		  RESULT = new ArrayList<>();
		  RESULT.add(e);
	     :}; 

expListE ::= expList:lst {: RESULT = lst; :} |
	      empty {: RESULT = new ArrayList<>(); :}; 

empty ::= ;
